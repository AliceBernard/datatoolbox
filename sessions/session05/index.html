<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Les donn√©es spatiales</title>
    <meta charset="utf-8" />
    <meta name="author" content="  Lorele√Ø GU√âRY Nicolas CASAJUS" />
    <link href="assets/libs/font-awesome-5.3.1/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../assets/css/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="../../assets/css/custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: right, middle, title-slide

# Les donn√©es spatiales
## <i><code>{sf}</code>¬†¬†<code>{raster}</code>¬†¬†<code>{ggplot2}</code></i>
### <br /><br />Lorele√Ø GU√âRY<br />Nicolas CASAJUS
### .inst[Mercredi 4 d√©cembre 2019]

---




class: inverse, center, middle

## Introduction

---


## Qu'est-ce qu'un objet spatial ?

<i class="fas  fa-hand-point-right "></i> &amp;nbsp;Deux cat√©gories :

**1)** Les donn√©es vectorielles

&lt;br /&gt;

.center[![:scale 100%](assets/img/vectors.png)]



---

## Qu'est-ce qu'un objet spatial ?

<i class="fas  fa-hand-point-right "></i> &amp;nbsp;Deux cat√©gories :

**2)** Les donn√©es matricielles

&lt;br /&gt;

.center[![:scale 100%](assets/img/rasters.png)]



---

## Le syst√®me de coordonn√©es

<i class="fas  fa-hand-point-right "></i> &amp;nbsp;Un objet spatial se repr√©sente
dans l'espace selon un r√©f√©rentiel spatial : le **syst√®me de coordonn√©es** (**CRS** pour _Coordinates Reference System_)

<i class="fas  fa-hand-point-right "></i> &amp;nbsp;Deux types de syst√®mes de coordonn√©es existent  :

**1)** Les syst√®mes g√©ographiques (ou non projet√©s) [en degr√©s]

.center[![:scale 100%](assets/img/projections01.png)]



---

## Le syst√®me de coordonn√©es

<i class="fas  fa-hand-point-right "></i> &amp;nbsp;Un objet spatial se repr√©sente
dans l'espace selon un r√©f√©rentiel spatial : le **syst√®me de coordonn√©es** (**CRS** pour _Coordinates Reference System_)

<i class="fas  fa-hand-point-right "></i> &amp;nbsp;Deux types de syst√®mes de coordonn√©es existent :

**2)** Les syst√®mes projet√©s [en m√®tres]

.center[![:scale 100%](assets/img/projections02.png)]

--

<i class="fas  fa-hand-point-right " style="color:#3f3f3f;"></i> &amp;nbsp;Le choix du CRS peut √™tre crucial et d√©pend souvent de l'information que l'on souhaite repr√©senter



---

## Le syst√®me de coordonn√©es

Sous <i class="fab  fa-r-project "></i> le CRS s'exprime selon le standard `proj4string` d√©fini par le projet [**PROJ**](https://proj.org/)

.small[`+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0`]

--

&lt;br /&gt;

Chaque CRS poss√®de un **SRID** (_Spatial Reference Identifier_) ou **EPSG**
(_European Petroleum Survey Group_) : un identifiant unique qui nous √©vite de
devoir √©crire √† la main le CRS au format `proj4string`

`+init=epsg:4326` est l'identifiant du CRS ci-dessus

.small[`+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0`]

&lt;br /&gt;

--

<i class="fas  fa-hand-point-right " style="color:#3f3f3f;"></i> &amp;nbsp;O√π trouver le bon CRS ? R√©ponse : [**Spatial Reference**](https://spatialreference.org/)



---
class: inverse, center, middle

## Objets vectoriels

---


## Les packages <i class="fab  fa-r-project "></i> - Vecteurs

Package           | Fonctionnalit√©s
------------------|------------------
`{sp}`            | Classes et m√©thodes pour couches vectorielles
`{rgdal}`         | Lecture et √©criture de couches spatiales
`{rgeos}`         | Op√©rations spatiales sur couches vectorielles
`{maptools}`      | Op√©rations spatiales sur couches vectorielles
`{sf}`            | Le petit dernier - Une vraie b√™te !

&lt;br /&gt;

<i class="fas  fa-hand-point-right " style="color:#3f3f3f;"></i> &amp;nbsp;`{sf}` est devenu la "norme" : `{sf} = {sp} + {rgdal} + {rgeos}`



---

## Pourquoi `{sf}` ?

- Impl√©mentation sous <i class="fab  fa-r-project "></i> des _Simple Features_
  - Standard reposant sur la norme ISO 19125 (stockage et acc√®s)
  - Remplace le format d'ESRI&lt;sup&gt;.small[TM]&lt;/sup&gt;, vous savez le shapefile !?

- 3 packages en 1

- Syntaxe (_snake_case_) des fonctions simples (`{st_*()}`)

- Objets stock√©s dans des `data.frame` ou des `tibble`
  - avec la g√©om√©trie stock√©e dans des `list-column`

- Tr√®s grandes performances compar√©es √† `{sp}`

- Pipe-friendly et int√©gration au tidyverse (dont `{ggplot2}`)

&lt;br /&gt;

<i class="fas  fa-hand-point-right " style="color:#3f3f3f;"></i> &amp;nbsp;Edzer Pebesma le recommende üòÑ



---

## Structure d'un objet `sf`

&lt;br /&gt;

.center[![:scale 100%](assets/img/str_sf.png)]



---

## Les _Simple feature geometry_ `sfg`


.center[![:scale 60%](assets/img/sf_obj.png)]



---

## Installation


```r
## install.packages("sf")

library("sf")
```

```
## Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0
```


---

## Cr√©ation de points spatiaux (1)

Soit les villes avec les coordonn√©es suivantes :





```r
paris     &lt;- c(2.3514992, 48.8566101)
marseille &lt;- c(5.3699525, 43.2961743)
lyon      &lt;- c(4.8320114, 45.7578137)
```

--

Convertissons ces vecteurs en points spatiaux :


```r
paris     &lt;- sf::st_point(paris)
marseille &lt;- sf::st_point(marseille)
lyon      &lt;- sf::st_point(lyon)
```

--

Et regroupons-les en un seul _spatial column_ en d√©finissant le CRS :


```r
villes &lt;- sf::st_sfc(
  list(paris, marseille, lyon),
  crs = 4326
)
class(villes)
```

```
## [1] "sfc_POINT" "sfc"
```

---

## Cr√©ation de points spatiaux (1)

Ajoutons une table d'attributs et convertissons l'objet en _simple  feature_ :


```r
datas &lt;- data.frame(
  ville      = c("Paris", "Marseille", "Lyon"),
  population = c(2190327, 862211, 515695)
)

villes &lt;- sf::st_sf(datas, geom = villes)
class(villes)
```

```
## [1] "sf"         "data.frame"
```

--

&lt;br /&gt;

<i class="fas  fa-hand-point-right " style="color:#3f3f3f;"></i> &amp;nbsp;Quid des lignes et polygones ?

<i class="fas  fa-hand-point-right " style="color:#e1ddc0;"></i> &amp;nbsp;Voir les fonctions `st_linestring()` et `st_polygon()`



---

## Cr√©ation de points spatiaux (2)

Bien souvent, vous importerez directement un `data.frame` que vous souhaiterez convertir en _simple feature_


```r
datas &lt;- data.frame(
  ville      = c("Paris", "Marseille", "Lyon"),
  lat        = c(48.8566101, 43.2961743, 45.7578137),
  lon        = c( 2.3514992,  5.3699525,  4.8320114),
  population = c(2190327, 862211, 515695)
)

(villes &lt;- sf::st_as_sf(datas, coords = c("lon", "lat"), crs = 4326))
```

```
## Simple feature collection with 3 features and 2 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: 2.351499 ymin: 43.29617 xmax: 5.369952 ymax: 48.85661
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
##       ville population                  geometry
## 1     Paris    2190327 POINT (2.351499 48.85661)
## 2 Marseille     862211 POINT (5.369953 43.29617)
## 3      Lyon     515695 POINT (4.832011 45.75781)
```


---

## Une premi√®re carte

Les packages `{rnaturalearth}` et `{rnaturalearthdata}` proposent diff√©rentes
couches vectorielles, dont les limites administratives des pays du monde.

Installons ces packages :


```r
## install.packages("rnaturalearth")
## install.packages("rnaturalearthdata")

library("rnaturalearth")
library("rnaturalearthdata")
```

--

Et chargeons le fond de carte du monde entier :


```r
world &lt;- ne_countries(scale = "medium", returnclass = "sf")
class(world)
```

```
## [1] "sf"         "data.frame"
```



---

## Une premi√®re carte

&lt;img src="assets/chunks/map1-1.png" width="100%" /&gt;


```r
ggplot(data = world) +
  geom_sf() +
  xlab("Longitude") + ylab("Latitude") + ggtitle("Carte du monde")
```



---

## Une premi√®re carte

&lt;img src="assets/chunks/map2-1.png" width="100%" /&gt;


```r
ggplot(data = world) +
  geom_sf(fill = "#49847b", colour = "#e1ddc0") +
  xlab("Longitude") + ylab("Latitude") + ggtitle("Carte du monde")
```



---

## Une premi√®re carte

&lt;img src="assets/chunks/map3-1.png" width="100%" /&gt;


```r
ggplot(data = world) +
  geom_sf(fill = "#49847b", colour = "#e1ddc0") +
  xlab("Longitude") + ylab("Latitude") + ggtitle("Carte du monde") +
  geom_sf(data = villes, colour = "black")
```



---

## Importation d'une couche vectorielle

Dans la plupart des cas, vous devrez importer une couche spatiale d√©j√† pr√™te.

T√©l√©chargeons les d√©partements de la r√©gion Occitanie


```r
## URL et nom du fichier
url      &lt;- "https://raw.githubusercontent.com/FRBCesab/datatoolbox/master/data/"
filename &lt;- "occitanie.zip"

## T√©l√©chargement du fichier
download.file(
  url      = paste0(url, filename),
  destfile = filename
)

## Extraction du ZIP
unzip(zipfile = filename)
```

---


- importation (st_read(), st_layers()) / exportation (st_drivers(), st_write())
- definition (st_crs, st_set_crs) projection (st_transform)


---

### st_*

- st_cast()
- st_crop()
- st_buffer()
- st_intersection()
- st_union()
- st_centroid()

### ggplot2

- geom_sf()
- coord_sf()
- scale_fill_viridis()
- mapView()

---

### dplyr

- select() keeps the specified variables, possibly renaming them
- rename() renames a variable and leaves all others unchanged
- filter() returns the rows that match the given conditions
- mutate() adds new variables based on existing variables
- transmute() creates new variables and drops existing variables
- arrange() sorts by the given variables
- slice() selects rows based on row number
- sample_n() samples n features randomly
- *_join()
- group_by(CODE_REG, NOM_REG) %&gt;%
- summarize()



---
class: inverse, center, middle

## Objets matriciels

---


## Title



---
class: inverse, center, middle

## Cartographie

---


## Title
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../../assets/libs/macros.js"></script>
<script>var slideshow = remark.create({
"ratio": "4:3",
"highlightStyle": "zenburn",
"highlightLines": false,
"countIncrementalSlides": false,
"slideNumberFormat": "%current% / %total%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
